---
title: 由客户端重复请求引发的幂等问题
categories:
  - 更多
tags:
  - 幂等
  - MySQL
date: 2022-03-25
description: 常见的接口参数加密方法，让接口不再裸奔。
---

最近在做项目的过程中，遇到了一个 **数据库里插入了重复数据** 的问题，当时还造成了一定的困扰。

在请教公司大佬，同时网上搜索后，才把问题弄清，其实就是 **接口幂等性** 的问题，记录一下。

## 1 问题引入

有这样一个场景：**新增用户时，往用户表里插入数据**

用户表类似这样：

| **字段**    | **类型** | **说明** |
| ----------- | -------- | -------- |
| id          | int      | 自增主键 |
| device_info | varchar  | 设备信息 |
| name        | varchar  | 用户名   |
| ...         |          |          |

处理流程：

1. 客户端调用登录接口，携带设备信息字段 deviceInfo；

2. 后台先根据 该设备信息参数 去数据库查询用户名是否存在；

   不存在则往用户表里新增一条记录；存在则进行后续业务操作。

代码示意：

```java
User user = userMapper.selectBykey(deviceInfo);
if(user == null) {
    // 执行插入insert
  }else {
 // 执行业务操作
 }
```

接口写完了，在客户端对接的过程中，发现数据库出现了一些重复记录，除了主键 id 外，其余信息完全一样。

查询日志发现 **insert into 语句同时执行了两次，**参数是一样的**，但是实际上这只是一个用户。**



刚开始想法太简单，不知道是什么原因。请教了公司同事进行排查，才知道是并发问题导致的。

客户端并发调用登录接口，同时进入了 if 条件判断语句内部，所以插入操作执行了两次。自己用 Jmeter 测试一下确实如此。

## 2 数据库层面解决

从数据库层面，为了防止数据库插入重复的数据，将 **device_info** 设置了唯一索引。

有以下几种解决方案：

### (1) insert ignore into

> 如果insert into 两条 device_info 相同的数据，则会报错 `Duplicate entry`

```sql
INSERT INTO user_info ( device_info，name ) VALUES ('250'，'Zhangsan'), ('250','lisi');
----
 Duplicate entry '250' for key ''device_info''
```

使用 `insert ignore into`，插入数据时，会判断主键或者唯一索引是否有重复，如果有重复则不执行，也不会报错。

> 例如，向数据库插入两条相同的数据，最后数据库中只会存在一条记录。

```sql
INSERT INTO user_info ( device_info，name )VALUES 
('251','Zhangsan'), 
('251'，'lisi');
----
> Affected rows: 1
```

### (2) on duplicate key update

插入一条记录，若该数据的主键值或者 UNIQUE KEY 已经在表中存在，**则执行更新操作，即UPDATE 后面的操作；**  否则插入一条新的记录。

> 如下sql语句，已经存在唯一索引 user_info = 250的记录，则只会执行更新操作，不会再次插入

```sql
INSERT INTO user ( device_info, name )
VALUES
	( '251', 'zhangsan' ) 
	ON DUPLICATE KEY UPDATE name = 'wangwu'
----
> Affected rows: 2
```

查看表，之前的记录被更新了

### (3) replace into

使用 `REPLACE INTO`，如果存在主键或者 UNIQUE KEY 相同的记录，则会 **删除原数据** ，然后重新插入新的数据。

```sql
REPLACE INTO USER ( device_info, NAME )
VALUES
	( '251', 'zhangsan' )
----
> Affected rows: 2
```

查看表，之前的记录删除了，同时新增一条记录。



在项目中暂时使用了将字段 device_info 设置为唯一索引，插入语句改为 insert ignore into 来进行处理。

但是如果对于上线的数据库，已经有重复的数据入库了，这个时候又没办法筛选出重复的数据，无法建立唯一索引。

也可以使用`Redis` 的 `setnx ` 指令来实现，或者使用 Redisson 实现 Redis分布式锁，这里暂时不细说了。

## 3 什么是幂等

针对上述问题，需要保证接口的 **幂等性** 。

### (1) 定义

幂等性(Idempotence)。在HTTP/1.1规范中幂等性的定义是：

> Methods can also have the property of "idempotence" in that (aside from error or expiration issues) the side-effects of N > 0 identical requests is the same as for a single request.

维基百科上的定义：

>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。
>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。
>
>用数学语言表达就是`f(x)=f(f(x))`。
>
>**幂等函数** ，或 **幂等方法** ，是指可以使用相同参数重复执行，并能获得相同结果的函数。

如果一个接口满足 **以相同的请求调用这个接口一次和调用这个接口多次，对系统产生的影响是相同的** ，那么就说这个接口是一个幂等接口。

### (2) 需要幂等性的场景

在编程中主要操作就是 CURD，其中读取（Retrieve）操作和删除（Delete）操作是天然幂等的，受影响的就是创建（Create）、更新（Update）

对于业务中需要考虑幂等性的地方一般都是接口的重复请求，即同一个请求因为某些原因被多次提交。导致这个情况会有几种场景：

- 前端重复提交：提交订单，用户快速重复点击多次，造成后端生成多个内容重复的订单。
- 接口超时重试：对于给第三方调用的接口，为了防止网络抖动或其他原因造成请求丢失，这样的接口一般都会设计成超时重试多次。
- 消息重复消费：MQ 消息中间件，消息重复消费。

### (3) 幂等性的实现方式

对于和 web 端交互的接口，在前端防止表单重复提交，可以采用点击提交按钮后置灰、隐藏、不可点击等方式，目前做的一些管理后台系统都在这么干，虽然粗糙了点。

还可以采用以下几种实现方式

#### 数据库唯一主键

适用于执行插入操作时的幂等性，利用数据库中主键唯一约束的特性，能保证一张表中只能存在一条带该唯一主键的记录。也就是标题 2 中提到的几种方法

#### 乐观锁

适用于执行更新操作的接口，可以提前在对应的数据表中多添加一个字段，比如当前时间戳，充当当前数据的版本标识。

时间戳标识由前端到数据中查询出来，再传给执行更新操作的接口；

执行完更新操作后，时间戳也被更新，这样重复执行该条 SQL 语句将不生效

```sql
update table_xxx set name= #name#, timestamp = now() where id=#id# and timestamp=#timestamp#
```

#### Token 机制防重

流程：

1. 调用方在调用接口的时候先向后端请求一个全局 `ID（Token）`，并将 `Token` 存入`Redis`中；
2. 请求的时候携带这个全局 `ID` 一起请求（一般放到 `Headers` 中）；
3. 后端需要对这个 `Token` 作为 `Key`，用户信息作为 `Value` 到 `Redis` 中进行键值内容校验；
4. 如果 `Key` 存在且 `Value` 匹配就执行删除命令，然后正常执行后面的业务逻辑；
5. 如果不存在对应的 `Key` 或 `Value` 不匹配就返回重复执行的错误信息，这样来保证幂等操作。

这里可以使用 自定义注解 + 拦截器实现

#### 下游传递唯一序列号

流程：

1. 下游服务生成分布式 `ID` 作为序列号，然后执行请求调用上游接口，并附带 **唯一序列号 **与请求的 **认证凭据ID** ；
2. 上游服务进行安全效验，检测下游传递的参数中是否存在 **序列号** 和 **凭据ID** ；
3. 上游服务到 Redis 中检测是否存在对应的 **序列号** 与 **认证ID** 组成的 `Key`，如果存在就抛出重复执行的异常信息，然后响应下游对应的错误信息；
4. 如果不存在就以该 **序列号** 和 **认证ID** 组合作为 `Key`，以下游关键信息作为 `Value`，进而存储到 Redis 中，一定要设置过期时间，然后正常执行接来来的业务逻辑。

